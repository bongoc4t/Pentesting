#--- HTTP STATUS CODES
    Informational responses (100–199),
    Successful responses (200–299),
    Redirects (300–399),
    Client errors (400–499),
    and Server errors (500–599).

#--- PAM (PLUGGABLE AUTHENTICATION MODULES)
https://www.linux.com/news/understanding-pam/
 PAM is a collection of modules that essentially form a barrier between a
service on your system, and the user of the service. The modules can have
widely varying purposes, from disallowing a login to users from a particular
UNIX group (or netgroup, or subnet…), to implementing resource limits so
that your ‘research’ group can’t hog system resources.
PAM is used by major commercial UNIX flavors such as AIX, HP-UX and Solaris,
as well as the major free versions of UNIX, like FreeBSD. Almost all
distributions of Linux also implement PAM, though I believe Slackware is
still the one notable holdout in this area. 
/etc/pam.conf
/etc/pam.d
/etc/pam.d/login


#--- BADCHARS
badchars = ( "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff") 
x = badchars.encoded()

#--- MOUNT SHARED FOLDERS
mount -f cifs //IPADDRESS/FOLDER


#--- CURL
curl -k HTTP://SITE -o FILENAME

-o <file>    # --output: write to file
-u user:pass # --user: Authentication
-v           # --verbose
-vv          # Even more verbose
-s           # --silent
-i           # --include: Include the HTTP-header in the output
-I           # --head: headers only
-k           # --insecure        # for self-signed certs


#--- EXIFTOOL (Steganography) ---
sudo apt install libimage-exiftool-perl > install if not have it
It's a open source program for reading, modifying, and manipulating images, videos, audios and PDF metadata.
Metadata are the additional data added to multimedia files. For example, the metadata of photographs are the
additional data like the name of the device, the resolution of the image, the location the image was taken at, 
the date of capture and modification and more.

exiftool FILE     -> list all metadata
exiftool -h FILE > FILE.html      -> export metadata to html file


#--- BINWALK (Steganography) ---
Binwalk is a tool for searching a given binary image for embedded files and executable code. Specifically, 
it is designed for identifying files and code embedded inside of firmware images. Binwalk uses the libmagic 
library, so it is compatible with magic signatures created for the Unix file utility. Binwalk also includes 
a custom magic signature file which contains improved signatures for files that are commonly found in firmware 
images such as compressed/archived files, firmware headers, Linux kernels, bootloaders, filesystems, etc
SIGNATURE SCAN OPTIONS
    -B, --signature              Scan target file(s) for common file signatures
    -R, --raw=<str>              Scan target file(s) for the specified sequence of bytes
    -A, --opcodes                Scan target file(s) for common executable opcode signatures
    -m, --magic=<file>           Specify a custom magic file to use
    -b, --dumb                   Disable smart signature keywords
    -I, --invalid                Show results marked as invalid
    -x, --exclude=<str>          Exclude results that match <str>
    -y, --include=<str>          Only show results that match <str>
EXTRACTION OPTIONS
   -e, --extract                Automatically extract known file types
    -D, --dd=<type:ext:cmd>      Extract <type> signatures, give the files an extension of <ext>, and execute <cmd>
    -M, --matryoshka             Recursively scan extracted files
    -d, --depth=<int>            Limit matryoshka recursion depth (default: 8 levels deep)
    -C, --directory=<str>        Extract files/folders to a custom directory (default: current working directory)
    -j, --size=<int>             Limit the size of each extracted file
    -n, --count=<int>            Limit the number of extracted files
    -r, --rm                     Delete carved files after extraction
    -z, --carve                  Carve data from files, but don't execute extraction utilities
    -V, --subdirs                Extract into sub-directories named by the offset
GENERAL OPTIONS
    -l, --length=<int>           Number of bytes to scan
    -o, --offset=<int>           Start scan at this file offset
    -O, --base=<int>             Add a base address to all printed offsets
    -K, --block=<int>            Set file block size
    -g, --swap=<int>             Reverse every n bytes before scanning
    -f, --log=<file>             Log results to file
    -c, --csv                    Log results to file in CSV format
    -t, --term                   Format output to fit the terminal window
    -q, --quiet                  Suppress output to stdout
    -v, --verbose                Enable verbose output
    -h, --help                   Show help output
    -a, --finclude=<str>         Only scan files whose names match this regex
    -p, --fexclude=<str>         Do not scan files whose names match this regex
    -s, --status=<int>           Enable the status server on the specified port

#--- FIND
find / -type [d/f] [-name, =perm] FILE 2>/dev/null

#--- CREATING PATTERNS FOR BUFFER OVERFLOWS
msf-pattern_create -l NUMBER
once we get the EIP HEX crash, copy/remember the numbers
msf-pattern_offset -l NUMBER -q EIP_HEX_CRASH
this will get us in which char number app crashes